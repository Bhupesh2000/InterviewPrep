ðŸ§© Problem: Subset Sum / Combination Sum (No Duplicates)
ðŸ”¹ Given:
    a list of distinct positive integers and a target sum

ðŸ”¹ Task:  
    Return all unique combinations of numbers that sum up to the target.
    Each number can be used only once in a combination.

    Input: nums = [2, 3, 6, 7], target = 9

    Output:
    [
    [3, 6],
    [2, 7]
    ]

Brute Force Approach(Recursive + check sum)

void SubSetSum(vector<int>& nums, vector<int>& current, int index, int k, vector<vector<int>>& ans){
    if(index == nums.size()){
        int sum = 0;
        for(int i = 0; i < current.size(); i++){
            sum += current[i];
        }
        if(sum == k) ans.push_back(current);
        return;
    }
    
    current.push_back(nums[index]);
    SubSetSum(nums, current, index + 1, k, ans);
    
    current.pop_back();
    SubSetSum(nums, current, index + 1, k, ans);
}

vector<vector<int>> SubSetSum(vector<int> nums, int k){
    vector<vector<int>> ans;
    vector<int> current;

    SubSetSum(nums, current, 0, k, ans);
    
    return ans;
}

--------------------------------------------------------------------------------------------------------------------------------------------

Optimised Binary Approach

void SubSetSum(vector<int>& nums, vector<int>& current, int index, int currentSum, vector<vector<int>>& ans){
    if(index == nums.size()){
        if(currentSum == 0) ans.push_back(current);
        return;
    }
    
    current.push_back(nums[index]);
    SubSetSum(nums, current, index + 1, currentSum - nums[index], ans);
    
    current.pop_back();
    SubSetSum(nums, current, index + 1, currentSum, ans);
}

vector<vector<int>> SubSetSum(vector<int> nums, int k){
    vector<vector<int>> ans;
    vector<int> current;

    SubSetSum(nums, current, 0, k, ans);
    
    return ans;
}

--------------------------------------------------------------------------------------------------------------------------------------------

Backtracking with Pruning

sort(nums.begin(), nums.end());

for (int i = index; i < nums.size(); i++) {
    if (nums[i] > currentSum) break;  // â† Your optimization

    current.push_back(nums[i]);
    backtrack(i + 1, currentSum - nums[i]);  // index+1 â†’ element used once
    current.pop_back();
}

--------------------------------------------------------------------------------------------------------------------------------------------

Approach                  |  Description	                             |       Time Complexity	   |         Space Complexity
--------------------------|----------------------------------------------|-----------------------------|---------------------------------------
Brute Force (Recursive +  |  Generate all 2^n subsets using recursion,   |    O(2^n * n)               |   O(n) recursion stack + O(mÂ·n) result
    Check Sum)            |  sum each subset at leaf nodes               |                             |
--------------------------|----------------------------------------------|-----------------------------|---------------------------------------
Optimized Recursive       |  Track currentSum as you recurse             |    O(2^n)                   |   O(n) recursion stack + O(mÂ·n) result
                          |  (no summing at leaf),                       |                             |
                          |  still explore all subsets                   |                             |
--------------------------|----------------------------------------------|-----------------------------|---------------------------------------
Backtracking with Pruning |  Sort input, stop recursion early            |    O(2^n) (avg-case         |   O(n) recursion stack + O(mÂ·n) result
                          |  if nums[i] > currentSum                     |    faster due to pruning)   |
                            