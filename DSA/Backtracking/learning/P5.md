ðŸ§© Problem: N-Queens

ðŸ”¹ Given:
    Integer n

ðŸ”¹ Task:
    Find all valid board configurations with N queens on an NÃ—N chessboard so that no two queens attack each other. Queens can attack vertically, horizontally, and diagonally.

Example:
    N = 4

    Total Sol = 2
    . Q . .
    . . . Q
    Q . . .
    . . Q .

    or

    . . Q .
    Q . . .
    . . . Q
    . Q . .


Recursive Approach

bool isSafe(int row, int col, vector<string> board, int N){
    for(int i = row - 1; i >= 0; i --)
        if(board[i][col] == 'Q') return false;
    for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i --, j --)
        if(board[i][j] == 'Q') return false;
    for(int i = row - 1, j = col + 1; i >= 0 && j < N; i --, j ++)
        if(board[i][j] == 'Q') return false;
        
    return true;
}

void solveNQueens(int row, vector<string>& board, int N, vector<vector<string>>& ans){
    if(row == N){
        ans.push_back(board);
        return;
    }
    
    for(int col = 0; col < N; col ++){
        if(isSafe(row, col, board, N)){
            board[row][col] = 'Q';
            solveNQueens(row + 1, board, N, ans);
            board[row][col] = '.';
        }
    }
}

vector<vector<string>> solveNQueens(int N){
    vector<vector<string>> ans;
    vector<string> board(N, string(N, '.'));
    
    solveNQueens(0, board, N, ans);
    
    return ans;
}

| **Aspect**      | **Complexity**     | **Explanation**                                            |
| --------------- | ------------------ | ---------------------------------------------------------- |
| Time Complexity | O(N!)              | Try placing 1 queen per row with safe column pruning       |
| Recursive Stack | O(N)               | One recursive call per row                                 |
| Board Space     | O(NÂ²)              | NÃ—N board to track current queen placement                 |
| Answer Storage  | O(m Ã— NÂ²)          | m solutions, each storing a full NÃ—N board                 |
| Total Space     | O(NÂ² + N + m Ã— NÂ²) | Board + stack + all solutions; dominated by solution space |

--------------------------------------------------------------------------------------------------------------------------------------------

Backtracking Approach

void solveNQueens(int row, vector<string>& board, int N, vector<bool>& colsUsed, vector<bool>& diag1, vector<bool>& diag2,  vector<vector<string>>& ans){
    if(row == N){
        ans.push_back(board);
        return;
    }
    
    for(int col = 0; col < N; col ++){
        if(!colsUsed[col] && !diag1[row - col + N - 1] && !diag2[row + col]){
            board[row][col] = 'Q';
            colsUsed[col] = diag1[row - col + N - 1] = diag2[row + col] = true;
            solveNQueens(row + 1, board, N, colsUsed, diag1, diag2, ans);
            board[row][col] = '.';
            colsUsed[col] = diag1[row - col + N - 1] = diag2[row + col] = false;
        }
    }
}

vector<vector<string>> solveNQueens(int N){
    vector<vector<string>> ans;
    vector<string> board(N, string(N, '.'));
    
    vector<bool> colsUsed(N, 0), diag1(2 * N - 1), diag2(2 * N - 1);
    
    solveNQueens(0, board, N, colsUsed, diag1, diag2,  ans);
    
    return ans;
}


| **Aspect**          | **Complexity**         | **Explanation**                                                                |
| ------------------- | ---------------------- | ------------------------------------------------------------------------------ |
| **Time Complexity** | `O(N!)`                | At most `N!` valid queen placements; constant-time safety checks using arrays. |
| **Recursion Depth** | `O(N)`                 | One recursive call per row (max `N` rows).                                     |
| **Board Space**     | `O(N^2)`               | Stores the current configuration of the board.                                 |
| **Auxiliary Space** | `O(N)`                 | For `colsUsed`, `diag1`, `diag2` (each â‰ˆ `O(N)` size).                         |
| **Result Space**    | `O(M * N^2)`           | `M` is number of valid solutions; each board has `N^2` characters.             |
| **Total Space**     | `O(M * N^2 + N^2 + N)` | Result + board + recursion + tracking arrays.                                  |

--------------------------------------------------------------------------------------------------------------------------------------------

Optimised with Bitmasking

void solve(int row, int n, int colMask, int diag1Mask, int diag2Mask, vector<string>& board, vector<vector<string>>& res) {
    if (row == n) {
        res.push_back(board);
        return;
    }

    for (int col = 0; col < n; col++) {
        int colBit = 1 << col;
        int d1Bit = 1 << (row - col + n - 1);
        int d2Bit = 1 << (row + col);

        if ((colMask & colBit) || (diag1Mask & d1Bit) || (diag2Mask & d2Bit))
            continue;

        board[row][col] = 'Q';
        solve(row + 1, n,
              colMask | colBit,
              diag1Mask | d1Bit,
              diag2Mask | d2Bit,
              board, res);
        board[row][col] = '.';
    }
}

vector<vector<string>> solveNQueens(int n) {
    vector<vector<string>> res;
    vector<string> board(n, string(n, '.'));
    solve(0, n, 0, 0, 0, board, res);
    return res;
}

| **Aspect**           | **Complexity**        | **Explanation**                                                                |
| -------------------- | --------------------- | ------------------------------------------------------------------------------ |
| **Time Complexity**  | `O(N!)`               | One queen per row, with `N` choices reducing each level (like backtracking)    |
| **Space Complexity** | `O(m * NÂ² + N + NÂ²)`  | `m * NÂ²` for storing all boards, `O(N)` for recursion stack, `O(NÂ²)` for board |
| **Improvement**      | Better constant space | Saves space over backtracking by using `int` for cols/diags instead of arrays  |
