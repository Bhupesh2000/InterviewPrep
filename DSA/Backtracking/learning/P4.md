üß© Problem: Combination Sum (with Duplicates Allowed)

üîπ Given:
    You are given an array of positive integers candidates (can include duplicates) and a target integer target.

üîπ Task:
    Find all unique combinations where:
        The same number can be chosen unlimited times
        The numbers must sum up to the target
        You can return the combinations in any order

Example:
    Input: candidates = [2, 3, 6, 7], target = 7

    Output: [
    [2, 2, 3],
    [7]
    ]

‚úÖ Constraints:
    1 ‚â§ candidates.length ‚â§ 30
    1 ‚â§ candidates[i] ‚â§ 200
    1 ‚â§ target ‚â§ 500
    All elements are positive integers
    No need to remove duplicates in input ‚Äî but your result should not have duplicate combinations

Brute Force Approach(Recursive + check sum)

void SubSetSumDuplicate(vector<int>& nums, vector<int>& current, int index, int target, vector<vector<int>>& ans){
    int sum = 0;
    for(int i = 0; i < current.size(); i++){
        sum += current[i];
    }
    if(sum == target){
        ans.push_back(current);
        return;
    }
    if(index == nums.size() || sum > target) return;
    
    current.push_back(nums[index]);
    SubSetSumDuplicate(nums, current, index, target, ans);
    
    current.pop_back();
    SubSetSumDuplicate(nums, current, index + 1, target, ans);
}

vector<vector<int>> SubSetSumDuplicate(vector<int> nums, int k){
    vector<vector<int>> ans;
    vector<int> current;

    SubSetSumDuplicate(nums, current, 0, k, ans);
    
    return ans;
}

| Component        | Complexity     | Notes                                           |
| ---------------- | -------------- | ----------------------------------------------- |
| Time             | `O(2^N * K^2)` | Without sum optimization                        |
|                  | `O(2^N * K)`   | If `currentSum` is passed instead of recomputed |
| Recursion Stack  | `O(K)`         | Max depth if repeatedly adding 1                |
| `current` Vector | `O(K)`         | Stores one valid combination                    |
| Output Storage   | `O(2^N * K)`   | Number of valid results                         |

--------------------------------------------------------------------------------------------------------------------------------------------

Optimised Recursive Approach

void SubSetSumDuplicate(vector<int>& nums, vector<int>& current, int index, int currentSum, vector<vector<int>>& ans){
    if(currentSum == 0){
        ans.push_back(current);
        return;
    }
    if(index == nums.size() || currentSum < 0) return;
    
    current.push_back(nums[index]);
    SubSetSumDuplicate(nums, current, index, currentSum - nums[index], ans);
    
    current.pop_back();
    SubSetSumDuplicate(nums, current, index + 1, currentSum, ans);
}

vector<vector<int>> SubSetSumDuplicate(vector<int> nums, int k){
    vector<vector<int>> ans;
    vector<int> current;

    SubSetSumDuplicate(nums, current, 0, k, ans);
    
    return ans;
}

| **Component**       | **Complexity** | **Explanation**                                                               |
| ------------------- | -------------- | ----------------------------------------------------------------------------- |
| **Time Complexity** | `O(2^N * K)`   | `2^N` subset choices; `K` from depth when smallest number is repeatedly added |
| **Recursion Stack** | `O(K)`         | Max depth = number of elements needed to reach sum `K` (e.g., adding 1s)      |
| **Current Vector**  | `O(K)`         | At most `K` elements to build a combination summing to `K`                    |
| **Output Storage**  | `O(2^N * K)`   | Stores all valid subsets; worst case has exponential number of results        |
| **Work per Call**   | `O(1)`         | `currentSum` is passed instead of recalculated                                |

--------------------------------------------------------------------------------------------------------------------------------------------

Backtracking with Pruning

void SubSetSumDuplicate(vector<int>& nums, vector<int>& current, int index, int currentSum, vector<vector<int>>& ans){
    if(currentSum == 0){
        ans.push_back(current);
        return;
    }
    if(currentSum < 0) return;
    
    for(int i = index; i < nums.size(); i++){
        current.push_back(nums[i]);
        SubSetSumDuplicate(nums, current, i, currentSum - nums[i], ans);
        current.pop_back();
    }
}

vector<vector<int>> SubSetSumDuplicate(vector<int> nums, int k){
    vector<vector<int>> ans;
    vector<int> current;
    sort(nums.begin(), nums.end());
    SubSetSumDuplicate(nums, current, 0, k, ans);
    
    return ans;
}

| **Component**       | **Complexity**                                    | **Explanation**                                                                         |
| ------------------- | ------------------------------------------------- | --------------------------------------------------------------------------------------- |
| **Time Complexity** | `O(2^N * K)` worst case<br>**Better in practice** | Same theoretical worst case as recursion, but avoids many branches early due to pruning |
| **Sorting Time**    | `O(N log N)`                                      | One-time cost to sort the input for pruning                                             |
| **Recursion Stack** | `O(K)`                                            | Max depth = max number of elements in a valid subset summing to `K`                     |
| **Current Vector**  | `O(K)`                                            | Holds a single combination in progress                                                  |
| **Output Storage**  | `O(2^N * K)`                                      | Stores all valid combinations; worst-case number of combinations is exponential         |
| **Work per Call**   | `O(1)`                                            | No recomputation of sum; checks and decisions are constant time                         |

------------------------------------------------------------------------------------------------------------------------------------------------

| Approach         | Time (Worst Case)       | Time (Practical)             | Space (Excl. Output) | Output Storage | Sorting        |
| ---------------- | ----------------------- | ---------------------------- | ---------------------| -------------- | -------------- |
| **Brute Force**  | `O(2^N * K^2)`          | ‚ùå Slow                       | `O(K)`               | `O(2^N * K)`   | ‚ùå              |
| **Recursion**    | `O(2^N * K)`            | üü° Moderate                   | `O(K)`               | `O(2^N * K)`   | ‚ùå              |
| **Backtracking** | `O(2^N * K)` worst case | ‚úÖ Faster (due to pruning)    | `O(K)`               | `O(2^N * K)`   | ‚úÖ `O(N log N)` |
